/*
  Copyright (C) 2015 Guy Sherman, Shermann Innovations Limited

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/

// C++ Standard Headers
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdint>
#include <arpa/inet.h>

// C Standard Headers


// Boost Headers


// 3rd Party Headers
#include "jdksmidi/world.h"
#include "jdksmidi/track.h"
#include "jdksmidi/multitrack.h"
#include "jdksmidi/filereadmultitrack.h"
#include "jdksmidi/fileread.h"
#include "jdksmidi/fileshow.h"
#include "jdksmidi/filewritemultitrack.h"

// GTK Headers


// Our Headers
#include <buffer/ByteBuffer.hxx>
#include "MidiExporter.hxx"

namespace exgen
{
	int MidiExporter::ExportExerciseToMidiFile(uint8_t *exercise, size_t exerciseLength, const char *filePath)
	{

			int return_code = -1;

		    jdksmidi::MIDITimedBigMessage m; // the object for individual midi events
		    unsigned char chan, // internal midi channel number 0...15 (named 1...16)
		        note, velocity, ctrl, val;

		    jdksmidi::MIDIClockTime t; // time in midi ticks
		    jdksmidi::MIDIClockTime dt = 25; // time interval (1 second)
		    int clks_per_beat = 100; // number of ticks in crotchet (1...32767)
		    int num_tracks = 2; // tracks 0 and 1

		    jdksmidi::MIDIMultiTrack tracks( num_tracks );  // the object which will hold all the tracks
		    tracks.SetClksPerBeat( clks_per_beat );
		    int trk; // track number, 0 or 1

		    t = 0;
		    m.SetTime( t );

		    // track 0 is used for tempo and time signature info, and some other stuff

		    trk = 0;

		    /*
		      SetTimeSig( numerator, denominator_power )
		      The numerator is specified as a literal value, the denominator_power is specified as (get ready!)
		      the value to which the power of 2 must be raised to equal the number of subdivisions per whole note.
		      For example, a value of 0 means a whole note because 2 to the power of 0 is 1 (whole note),
		      a value of 1 means a half-note because 2 to the power of 1 is 2 (half-note), and so on.
		      (numerator, denominator_power) => musical measure conversion
		      (1, 1) => 1/2
		      (2, 1) => 2/2
		      (1, 2) => 1/4
		      (2, 2) => 2/4
		      (3, 2) => 3/4
		      (4, 2) => 4/4
		      (1, 3) => 1/8
		    */

		    m.SetTimeSig( 4, 2 ); // measure 4/4 (default values for time signature)
		    tracks.GetTrack( trk )->PutEvent( m );

		    int tempo = 1000000; // set tempo to 1 000 000 usec = 1 sec in crotchet
		    // with value of clks_per_beat (100) result 10 msec in 1 midi tick
		    // If no tempo is define, 120 beats per minute is assumed.

		    // m.SetTime( t ); // do'nt need, because previous time is not changed
		    m.SetTempo( tempo );
		    tracks.GetTrack( trk )->PutEvent( m );

		    // META_TRACK_NAME text in track 0 music notation software like Sibelius uses as headline of the music
		    tracks.GetTrack( trk )->PutTextEvent(t, jdksmidi::META_TRACK_NAME, "Generated by exercise-generator");

		    // create cannal midi events and add them to a track 1

		    trk = 1;

		    // META_TRACK_NAME text in tracks >= 1 Sibelius uses as instrument name (left of staves)
		    tracks.GetTrack( trk )->PutTextEvent(t, jdksmidi::META_TRACK_NAME, "Church Organ");

		    // we change panorama in channels 0-2

		    m.SetControlChange ( chan = 0, ctrl = 0xA, val = 64 ); // channel 0 panorama = 0 at the left
		    tracks.GetTrack( trk )->PutEvent( m );


		    // we change musical instrument in channels 0-2

		    m.SetProgramChange( chan = 0, val = 19 ); // channel 0 instrument 19 - Church Organ
		    tracks.GetTrack( trk )->PutEvent( m );


		    // create individual midi events with the MIDITimedBigMessage and add them to a track 1

		    t = 0;

		    // we add note 1: press and release in (dt) ticks

			for (int i = 0; i < exerciseLength; ++i)
			{
				m.SetTime( t );
			    m.SetNoteOn( chan = 0, note = exercise[i], velocity = 100 );
			    tracks.GetTrack( trk )->PutEvent( m );

			    m.SetTime( t += dt );
			    m.SetNoteOff( chan, note, velocity );
			    tracks.GetTrack( trk )->PutEvent( m );
			}






		    // if events in any track recorded not in order of the growth of time,
		    // tracks.SortEventsOrder(); // it is necessary to do this before write step

		    // to write the multi track object out, you need to create an output stream for the output filename

		    const char *outfile_name = filePath;
		    jdksmidi::MIDIFileWriteStreamFileName out_stream( outfile_name );

		    // then output the stream like my example does, except setting num_tracks to match your data

		    if( out_stream.IsValid() )
		    {
		        // the object which takes the midi tracks and writes the midifile to the output stream
		        jdksmidi::MIDIFileWriteMultiTrack writer( &tracks, &out_stream );

		        // write the output file
		        if ( writer.Write( num_tracks ) )
		        {
		            std::cout << "\nOK writing file " << outfile_name << std::endl;
		            return_code = 0;
		        }
		        else
		        {
		            std::cerr << "\nError writing file " << outfile_name << std::endl;
		        }
		    }
		    else
		    {
		        std::cerr << "\nError opening file " << outfile_name << std::endl;
		    }

		    return return_code;
	}
}
